#include <iostream>
#include <thread> // Multithreading
#include <vector> 
#include <queue> // For thread-safe queue
#include <mutex> // Synchronization
#include <condition_variable> // For signaling between threads
#include <random> // For random data generation
#include <chrono> // For sleep and timing
#include <atomic> // For atomic boolean
#include <iomanip> // For std::setprecision


struct WeatherReading { // Data generated by a sensor
    int sensor_id;
    double temperature;
    double humidity;
};

struct WeatherStats { // Aggregated statistics for the Visualizer
    double avg_temp = 0.0;
    double avg_hum = 0.0;
    int total_readings = 0;
    double max_temp = -100.0;
    double min_temp = 100.0;
};


std::queue<WeatherReading> sensor_queue; // 1. Queue for raw data (Sensors -> Aggregator)
std::mutex queue_mutex; // Synchronization for queue access
std::condition_variable queue_cv; // For signaling between threads

WeatherStats global_stats; // 2. Storage for processed stats (Aggregator -> Visualizer)
std::mutex stats_mutex; // Synchronization for stats access

std::atomic<bool> system_running(true); // Flag to signal all threads to stop


double random_double(double min, double max) { // Generates a random double within a range
    static std::mt19937 rng(std::random_device{}());
    std::uniform_real_distribution<double> dist(min, max);
    return dist(rng);
}


void sensor_thread_func(int id) { //Simulates hardware sensors reading environment data. Pushes data to the shared queue.
    while (system_running) {
        std::this_thread::sleep_for(std::chrono::milliseconds((int)random_double(500, 1500))); // Simulate time taken to read sensor (randomly between 500ms and 1500ms)

        WeatherReading reading; // Generate random weather data
        reading.sensor_id = id;
        reading.temperature = random_double(15.0, 35.0); // 15C to 35C
        reading.humidity = random_double(30.0, 80.0);    // 30% to 80%
        {
            std::lock_guard<std::mutex> lock(queue_mutex);
            sensor_queue.push(reading);
            std::cout << "[Sensor " << id << "] Data generated.\n"; 
        }
        queue_cv.notify_one();
    }
}


void aggregator_thread_func() { // Consumes data from the queue and updates global statistics.
    while (system_running) {
        WeatherReading data;

        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            
            // Wait until queue is not empty OR system is stopped
            queue_cv.wait(lock, []{ return !sensor_queue.empty() || !system_running; });

            if (!system_running && sensor_queue.empty()) break;

            data = sensor_queue.front();
            sensor_queue.pop();
        }

        std::cout << "[Aggregator] Processing data from Sensor " << data.sensor_id << ".\n";
        {
            std::lock_guard<std::mutex> lock(stats_mutex);
            
            // Recalculate averages using cumulative moving average formula or simple sum
            // Here we do a simple accumulation for clarity
            double current_total_temp = global_stats.avg_temp * global_stats.total_readings;
            double current_total_hum = global_stats.avg_hum * global_stats.total_readings;

            global_stats.total_readings++;
            global_stats.avg_temp = (current_total_temp + data.temperature) / global_stats.total_readings;
            global_stats.avg_hum = (current_total_hum + data.humidity) / global_stats.total_readings;

            if (data.temperature > global_stats.max_temp) global_stats.max_temp = data.temperature;
            if (data.temperature < global_stats.min_temp) global_stats.min_temp = data.temperature;
        }
    }
}


void visualizer_thread_func() { //Periodically wakes up, reads the stats, and prints a report.Does NOT interfere with data collection logic.
    while (system_running) {
        std::this_thread::sleep_for(std::chrono::seconds(2));

        if(!system_running) break;

        WeatherStats current_stats;
        {
            std::lock_guard<std::mutex> lock(stats_mutex);
            current_stats = global_stats; // Copy data to local var to minimize lock time
        }

        static int last_total = 0;
        int diff = current_stats.total_readings - last_total;
        last_total = current_stats.total_readings;
        double throughput = diff / 2.0; // readings per second over the last 2 seconds

        std::cout << "\n========================================\n";
        std::cout << " WEATHER MONITORING DASHBOARD\n";
        std::cout << "========================================\n";
        std::cout << " Throughput:               " << throughput << " readings/sec\n";
        std::cout << " Total Readings Processed: " << current_stats.total_readings << "\n";
        std::cout << std::fixed << std::setprecision(2);
        std::cout << " Average Temperature:      " << current_stats.avg_temp << " degree Celsius\n";
        std::cout << " Average Humidity:         " << current_stats.avg_hum << "%\n";
        std::cout << " Peak Temperature:         " << current_stats.max_temp << " degree Celsius\n";
        std::cout << " Low Temperature:          " << current_stats.min_temp << " degree Celsius\n";
        std::cout << "========================================\n";
    }
}


int main() {
    std::cout << "Starting Weather Monitoring Simulation...\n";
    std::cout << "Press ENTER to stop the simulation.\n";

    std::vector<std::thread> threads;

    
    threads.push_back(std::thread(sensor_thread_func, 1));
    threads.push_back(std::thread(sensor_thread_func, 2));
    threads.push_back(std::thread(sensor_thread_func, 3));
    threads.push_back(std::thread(aggregator_thread_func));
    threads.push_back(std::thread(visualizer_thread_func));

    std::cin.get();

    std::cout << "Shutting down simulation...\n";
    system_running = false;
    
    queue_cv.notify_all(); // Wake up the aggregator if it is sleeping on the empty queue

    for (auto& t : threads) {
        if (t.joinable()) t.join();
    }

    std::cout << "Simulation stopped gracefully.\n";
    return 0;
}